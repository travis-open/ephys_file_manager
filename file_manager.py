from pathlib import Path, PurePath
import shutil
import json
from datetime import date, datetime

from config import default_base_dir, src_list, rig_id
from nwb_info import process_nwb_in_dir
from data_models import Animal, SliceRecDay, BrainSlice, RecordingSite, RecordedCell



class DirectoryManager(object):
	"""Manages folder hierarchy and saving of metadata."""
	def __init__(self, default_base_dir=default_base_dir, rig_id=rig_id):

		self.base_directory = Path(default_base_dir)
		self.rig_id = rig_id
		self.active_directory = None
		self.directory_level = 'base'
		self.new_dir_time = None
		self.src_list = src_list
		##day (SliceRecordingDay) attributes
		self.animal_id = None
		self.project = None
		self.day_id = None
		self.date = None
		self.day_directory = None
		self.species = None ##for now (ever?) have option to define species on day, in case using animal w/o ID
		##BrainSlice attributes
		self.slice_id = None
		self.slice_id_short = None
		self.slice_directory = None
		self.slice_rig_time = None
		self.fixation_well_id = ''
		self.fixed_orientation = None
		self.plane = None
		##Site attributes
		self.site_id = None
		self.site_directory = None
		self.region = None
		self.external_solution = None

	def set_base_dir(self, path):
		"""Set base directory to indicated path. Reset attributes."""
		path = string_to_path(path)
		assert path.exists(), f"Base directory must already exist. {path} not found."
		self.base_directory = path
		self.active_directory = path
		self.new_dir_time = datetime.now()
		self.reset_attr("day")

	def reset_attr(self, level):
		"""Reset attributes associated with given level and all child levels."""
		if level == 'day':
			self.animal_id = None
			self.project = None
			self.day_id = None
			self.date = None
			self.day_directory = None
			self.species = None
			self.reset_attr(level='slice')
		if level == 'slice':
			self.slice_id = None
			self.slice_id_short = None
			self.slice_directory = None
			self.slice_rig_time = None
			self.fixation_well_id = ''
			self.fixed_orientation = None
			self.plane = None
			self.reset_attr(level='site')
		if level == 'site':
			self.site_directory = None
			self.site_id = None
			self.region = None
			self.external_solution = None

	def make_new_folder(self, path):
		"""Makes a new folder of the given Path. Sets the Path as the active directory and records the time."""
		path.mkdir()
		self.active_directory = path
		self.new_dir_time = datetime.now()

	def make_new_day(self, i=0, animal_id=None, project=None, save_current=True):
		"""
		Makes a new directory with today's date. Sets it as working directory.

		Arguments:
			i (iterative integer): defaults to 0. If a folder already exists with passed value, iterate to next integer.
		"""
		assert self.base_directory, 'base directory is not defined'
		day_directory_id = str(date.today())+f"-{i:03}"
		day_path = self.base_directory/day_directory_id
		if not day_path.exists():
			if save_current and self.directory_level != 'base': ##don't try to save something that's note there.
				self.save_data_model(model_level="current", gsheet=True)
			self.reset_attr('day')
			self.reset_attr('slice')
			self.make_new_folder(day_path)
			self.directory_level = 'day'
			self.day_directory = day_path
			self.day_id = day_directory_id
			self.date = date.today()
			##if animal_id is not given, make (hopefully temp) animal_id from day_id
			##example: 2024-02-09-003 => 'A20240209003'
			if animal_id is None:
				animal_id = 'A'+day_directory_id.replace('-','')
			self.animal_id = animal_id
			self.project = project
			
		else:
			i += 1
			self.make_new_day(i=i, animal_id=animal_id, project=project)

	def make_new_slice(self, i=0, slice_id='', save_current=True):
		"""
		Makes a new slice directory with current day directory. 
		Sets new slice folder as working directory.

		Arguments:
			i (iterative integer): defaults to 0. If a folder already exists with passed value, iterate to next integer.
			slice_id: defaults to an empty string. slice_id is intended to be unique to physical slice and include the 
			parent animal_id of the format A1234.sag_003. This will be distinct from the folder name generated by this function.
		"""
		if i > 999:  ##should not have 1000 slices
			raise ValueError('slice i greater than 1000 not supported')
		assert self.day_directory, "Cannot make a new slice directory if day directory is undefined."
		slice_path = self.day_directory/(f"slice-{i:03}") ##slice number padded to 3 digits
		if not slice_path.exists(): #make new directory and set path if it doesn't exist
			if save_current:
				self.save_data_model(model_level="current", gsheet=True)
			self.reset_attr('slice')
			self.reset_attr('site')
			self.make_new_folder(slice_path)
			self.directory_level = "slice"
			self.slice_directory = 	slice_path
			##if slice_id is not given, make (hopefully temporary) slice_id 
			##from slice_directory
			if slice_id == '':
				slice_id = self.slice_directory.stem
			self.slice_id = self.animal_id+"."+slice_id
			self.slice_rig_time = self.new_dir_time
		else:					#if path exists, increase slice number
			i += 1
			self.make_new_slice(i, slice_id=slice_id)

	def make_new_site(self, i=0, save_current=True):
		"""
		Makes a new site directory within current slice directory. 
		Sets new site folder as working directory.

		Arguments:
			i (iterative integer): defaults to 0. 
			If a folder already exists with passed value, iterate to next integer.

		"""
		if i > 999:
			raise ValueError('site i greater than 1000 not supported')
		assert self.day_directory, "Cannot make a new site directory if day directory is undefined."
		assert self.slice_directory, "Cannot make a new site directory if slice directory is undefined."
		site_name = f"site-{i:03}"
		site_path = self.slice_directory/site_name
		if not site_path.exists():
			if save_current:
				self.save_data_model(model_level="current", gsheet=True)
			self.reset_attr('site')
			self.make_new_folder(site_path)
			self.directory_level = 'site'
			self.site_directory = site_path
			self.site_id = self.slice_id+"."+site_name
		else:
			i+=1
			self.make_new_site(i)

	def copy_files_src_list(self):
		"""Copies files that have been modified after active directory creation to active directory.
		src_list could be list of default directories used by DAQ software"""
		for src in self.src_list:
			self.copy_files_since_tstamp(src)
		process_nwb_in_dir(directory=self.active_directory)

	def copy_files_since_tstamp(self, src, tstamp=None, dst=None):
		"""Copies all files modified after time (tstamp) from source directory (src) to destination directory (dst)."""
		if tstamp is None:
			tstamp = self.new_dir_time
		if dst is None:
			dst = self.active_directory
		src = string_to_path(src)
		assert src.exists(), f"source directory {src} does not exist."
		for file in src.iterdir():
			last_mod = last_mod_datetime(file)
			if last_mod > self.new_dir_time:
				shutil.copy2(file, dst)

	def predict_level_from_path(self, path):
		"""Predict directory level from folder names in Path object."""
		if path.parts[-1][-8:-4] == 'site':
			return 'site'
		elif path.parts[-1][-9:-4] == 'slice':
			return 'slice'
		elif path.parts[-1][:2] == '20':
			##bit clumsy solution. todo: come up with something better. At least before 2100.
			return 'day'
		else:
			print(f"warning - path {path} not recognized as day, slice or site folder")
			return ''

	def set_existing_dir(self, path, directory_level=None):
		"""Set active directory to an existing directory (path) and import metadata from a json (if present)."""
		path = string_to_path(path)
		assert path.exists(), f"target directory {path} does not exist."
		self.active_directory = path
		self.new_dir_time = datetime.now()
		if directory_level is None:
			directory_level = self.predict_level_from_path(path)
		self.directory_level = directory_level
		self.reset_attr(directory_level)
		json_file_name = self.directory_level + ".json"
		if Path(self.active_directory/json_file_name).exists():
			## validate json as pydantic model
			existing_model = self.build_model_from_json()
			model_dict = existing_model.model_dump()
			self.set_meta_attr(model_dict)
			


	def set_meta_attr(self, meta_dict):
		"""Set metadata attributes received as a dictionary (e.g. from user entry on a GUI), 
		including nested dictionaries."""
		for k, v in meta_dict.items():
			if isinstance(v, dict):
				self.set_meta_attr(v)
			elif k in vars(self) and v != '':
				self.__setattr__(k, v)

	def find_existing_meta_json(self):
		"""If json file with name matching current directory level is found, return as dictionary."""
		json_file_name = self.directory_level + ".json"
		existing_meta_dict = {}
		if Path(self.active_directory/json_file_name).exists():
			with open(self.active_directory/json_file_name) as f:
				existing_meta_dict = json.load(f)
		else:
			print (f"{json_file_name} not found")
		return existing_meta_dict

	def build_model_from_json(self):
		"""Return pydantic model based on existing json"""
		existing_meta_dict = self.find_existing_meta_json()
		if self.directory_level == 'day':
			model_out = SliceRecDay(**existing_meta_dict)
		if self.directory_level == 'slice':
			model_out = BrainSlice(**existing_meta_dict)
		if self.directory_level == 'site':
			model_out = RecordingSite(**existing_meta_dict)
		return model_out
	
	def build_model(self, model_level=None, meta_dict=None):
		"""
		Build pydantic data model (or nested models) from attributes of DirectoryManager. 
		Defaults to current/active level, but can be specified with model_level.
		"""
		assert self.directory_level in ['day', 'slice', 'site'], f"{self.directory_level} invalid directory level"
		dl_to_hier_dict = {'day':0, 'slice':1, 'site': 2}

		if meta_dict == None:
			meta_dict = self.__dict__

		if model_level == None:
			model_level = self.directory_level

		model_hier = dl_to_hier_dict[model_level]
		if model_hier >= 0:
			animal_model = Animal(**meta_dict)
			day_model = SliceRecDay(animal=animal_model, **meta_dict)
			model_out = day_model
		if model_hier >= 1:
			slice_model = BrainSlice(slice_rec_day=day_model, **meta_dict)
			model_out = slice_model
		if model_hier >= 2:
			site_model = RecordingSite(brain_slice=slice_model, **meta_dict)
			model_out = site_model
		return model_out

	def save_data_model(self, model_level="current", gsheet=False):
		"""Save models that correspond to directories as json and optionally send to google spreadsheet."""
		if model_level == "current":
			model_level = self.directory_level
		assert model_level in ['day', 'slice', 'site'], f"model level undefined and {self.directory_level} invalid directory level"
		data_model = self.build_model(model_level=model_level)
		self.data_model_to_json(data_model, model_level)
		if gsheet:
			try:
				data_model.gs_upload()
			except:
				print (f"upload to google spreadsheet not supported by data model {data_model}")

	def save_cell_data_model(self, cell_model, gsheet=False):
		"""Save RecordedCell data model to JSON and optionally google sheet."""
		jsonfile = "cell"+str(cell_model.headstage)+".json"
		dir_path = self.site_directory
		with open(dir_path/jsonfile, "w") as f:
			f.write(cell_model.model_dump_json(indent=4))
		if gsheet:
			try:
				cell_model.gs_upload()
			except:
				print (f"upload to google spreadsheet not supported by data model {cell_model}")

	def data_model_to_json(self, data_model, model_level):
		"""Save data model corresponding to a directory (day, slice, site) to json file."""
		jsonfile = model_level+".json"
		if model_level in ["day", "slice", "site"]:
			dir_name = model_level+"_directory"
		elif model_level == 'cell':
			dir_name = "site_directory"
		else:
			print (f"model_level {model_level} not supported. Accepted levels are day, slice, site.")
		dir_path = getattr(self, dir_name)
		with open(dir_path/jsonfile, "w") as f:
			f.write(data_model.model_dump_json(indent=4))

			
	def build_and_save_cell_model(self, HS, ext_dict, gsheet=False):
		cell_model = self.build_cell_model(HS, ext_dict)
		self.save_cell_data_model(cell_model, gsheet)

	def build_cell_model(self, HS, ext_dict=None):
		"""Create a RecordedCell data model using attributes of DirectoryManager
		and ext_dict (likely received from GUI)"""
		assert self.site_id, "Cannot create cell model without site_id."
		site_id = self.site_id
		cell_id = site_id + ".HS" + str(HS)
		site_directory = self.site_directory
		recording_site = self.build_model('site')
		cell_model = RecordedCell(cell_id=cell_id, site_id=site_id, 
			site_directory=site_directory, recording_site=recording_site, 
			headstage=HS, **ext_dict)
		return cell_model

	

def string_to_path(path):
	"""Return a pathlib Path object from entered path. 
	Converts to path from string if needed."""
	if isinstance(path, PurePath):
		return path
	elif isinstance(path, str):
		path = Path(r'{}'.format(path))
		return path

def last_mod_datetime(file):
	"""Return a datetime object representing the last time file was modified."""
	if isinstance(file, PurePath) == False:
		file = string_to_path(file)
	mod_datetime = datetime.fromtimestamp(file.lstat().st_mtime)
	return mod_datetime